// This file was generated by '@mattrax/drizzle-to-rs'
#![allow(unused)]
use chrono::NaiveDateTime;
use mysql_async::{prelude::*, Deserialized, Serialized};

#[derive(Debug)]
pub struct GetCertificateResult {
    pub certificate: Vec<u8>,
}

#[derive(Debug)]
pub struct GetDeviceResult {
    pub pk: i64,
    pub tenant_pk: i64,
}
#[derive(Debug)]
pub struct GetPolicyDataForCheckinLatestDeployResult {
    pub pk: i64,
    pub data: serde_json::Value,
}
#[derive(Debug)]
pub struct GetPolicyDataForCheckinLastDeployResult {
    pub pk: i64,
    pub data: serde_json::Value,
    pub result: serde_json::Value,
}
#[derive(Debug)]
pub struct GetPolicyDataForCheckinResult {
    pub scope: String,
    pub latest_deploy: GetPolicyDataForCheckinLatestDeployResult,
    pub last_deploy: Option<GetPolicyDataForCheckinLastDeployResult>,
}
#[derive(Debug)]
pub struct GetPoliciesRequiringRemovalResult {
    pub pk: i64,
    pub policy_pk: i64,
    pub data: serde_json::Value,
    pub result: serde_json::Value,
}
#[derive(Debug)]
pub struct QueuedDeviceActionsResult {
    pub action: String,
    pub device_pk: i64,
    pub created_by: i64,
    pub created_at: NaiveDateTime,
    pub deployed_at: Option<NaiveDateTime>,
}

pub struct DbInner {
    client: tokio_postgres::Client,
}

#[derive(Clone)]
pub struct Db(std::sync::Arc<DbInner>);

impl std::ops::Deref for Db {
    type Target = DbInner;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl Db {
    pub async fn new(db_url: &str) -> Self {
        let (client, connection) = tokio_postgres::connect(
            db_url,
            postgres_native_tls::MakeTlsConnector::new(
                native_tls::TlsConnector::builder().build().unwrap(),
            ),
        )
        .await
        .unwrap();

        tokio::spawn(async move {
            if let Err(e) = connection.await {
                eprintln!("connection error: {}", e);
            }
        });

        Self(std::sync::Arc::new(DbInner { client }))
    }
}

impl Db {
    pub async fn get_certificate(
        &self,
        key: String,
    ) -> Result<Vec<GetCertificateResult>, tokio_postgres::Error> {
        let resp = self
            .0
            .client
            .query(
                r#"select "certificate" from "certificates" where "certificates"."key" = $1"#,
                &[&key],
            )
            .await?;
        Ok(resp
            .into_iter()
            .map(|row| GetCertificateResult {
                certificate: row.get("certificate"),
            })
            .collect())
    }
}
impl Db {
    pub async fn store_certificate(
        &self,
        key: String,
        certificate: Vec<u8>,
    ) -> Result<(), tokio_postgres::Error> {
        let last_modified = chrono::Utc::now().naive_utc();
        let resp = self.0.client.query(r#"insert into "certificates" ("key", "certificate", "last_modified") values ($1, $2, $3) on conflict ("key") do update set "certificate" = $4, "last_modified" = $5"#, &[&key,&certificate,&last_modified,&certificate,&last_modified]).await?;
        Ok(())
    }
}
impl Db {
    pub async fn create_device(
        &self,
        id: String,
        name: String,
        enrollment_type: String,
        os: String,
        serial_number: String,
        tenant_pk: i64,
        owner_pk: i64,
    ) -> Result<(), tokio_postgres::Error> {
        let resp = self.0.client.query(r#"insert into "devices" ("pk", "id", "name", "description", "enrollment_type", "os", "serial_number", "manufacturer", "model", "os_version", "imei", "free_storage", "total_storage", "owner", "azure_ad_did", "enrolled_at", "last_synced", "tenant") values (default, $1, $2, default, $3, $4, $5, default, default, default, default, default, default, $6, default, default, default, $7) on conflict ("id") do update set "name" = $8, "owner" = $9, "tenant" = $10"#, &[&id,&name,&enrollment_type,&os,&serial_number,&owner_pk,&tenant_pk,&name,&owner_pk,&tenant_pk]).await?;
        Ok(())
    }
}
impl Db {
    pub async fn get_device(
        &self,
        device_id: String,
    ) -> Result<Vec<GetDeviceResult>, tokio_postgres::Error> {
        let resp = self
            .0
            .client
            .query(
                r#"select "pk", "tenant" from "devices" where "devices"."id" = $1"#,
                &[&device_id],
            )
            .await?;
        Ok(resp
            .into_iter()
            .map(|row| GetDeviceResult {
                pk: row.get("pk"),
                tenant_pk: row.get("tenantPk"),
            })
            .collect())
    }
}
impl Db {
    pub async fn get_policy_data_for_checkin(
        &self,
        device_pk: i64,
    ) -> Result<Vec<GetPolicyDataForCheckinResult>, tokio_postgres::Error> {
        let resp = self.0.client.query(r#"select "scope", "l"."pk", "l"."data", "k"."pk", "k"."data", "k"."result" from (select distinct on ("i"."policy") "pk", "policy", "data", "scope" from (select "policy_deploy"."pk", "policy_deploy"."policy", "policy_deploy"."data", "scope" from (select distinct on () "pk", "scope" from (select "pk", "scope" from ((select "policies"."pk", "direct" as "scope" from "policies" inner join "policy_assignables" on "policies"."pk" = "policy_assignables"."policy" where ("policy_assignables"."variant" = $1 and "policy_assignables"."pk" = $2)) union all (select "policies"."pk", "group" as "scope" from "policies" inner join "policy_assignables" on ("policies"."pk" = "policy_assignables"."policy" and "policy_assignables"."variant" = $3) inner join "group_assignables" on "group_assignables"."group" = "policy_assignables"."pk" where ("group_assignables"."variant" = $4 and "group_assignables"."pk" = $5))) "scoped" order by "scope" asc) "sorted") "sp" inner join "policy_deploy" on "sp"."pk" = "policy_deploy"."policy" order by "policy_deploy"."done_at" desc) "i") "l" left join (select distinct on ("j"."policy") "pk", "policy", "result", "data" from (select "policy_deploy"."pk", "policy_deploy"."policy", "policy_deploy_status"."result", "policy_deploy"."data" from (select distinct on () "pk", "scope" from (select "pk", "scope" from ((select "policies"."pk", "direct" as "scope" from "policies" inner join "policy_assignables" on "policies"."pk" = "policy_assignables"."policy" where ("policy_assignables"."variant" = $6 and "policy_assignables"."pk" = $7)) union all (select "policies"."pk", "group" as "scope" from "policies" inner join "policy_assignables" on ("policies"."pk" = "policy_assignables"."policy" and "policy_assignables"."variant" = $8) inner join "group_assignables" on "group_assignables"."group" = "policy_assignables"."pk" where ("group_assignables"."variant" = $9 and "group_assignables"."pk" = $10))) "scoped" order by "scope" asc) "sorted") "sp" inner join "policy_deploy" on "sp"."pk" = "policy_deploy"."policy" inner join "policy_deploy_status" on ("policy_deploy"."pk" = "policy_deploy_status"."deploy" and "policy_deploy_status"."device" = $11) order by "policy_deploy"."done_at" desc) "j") "k" on "k"."policy" = "l"."policy""#, &[&"device",&device_pk,&"group",&"device",&device_pk,&"device",&device_pk,&"group",&"device",&device_pk,&device_pk]).await?;
        Ok(resp
            .into_iter()
            .map(|row| GetPolicyDataForCheckinResult {
                scope: row.get("scope"),
                latest_deploy: GetPolicyDataForCheckinLatestDeployResult {
                    pk: row.get("pk"),
                    data: row.get("data"),
                },
                last_deploy: {
                    let pk = row.try_get("pk");
                    let data = row.try_get("data");
                    let result = row.try_get("result");

                    match (pk, data, result) {
                        (Ok(pk), Ok(data), Ok(result)) => {
                            Some(GetPolicyDataForCheckinLastDeployResult { pk, data, result })
                        }
                        _ => None,
                    }
                },
            })
            .collect())
    }
}
impl Db {
    pub async fn get_policies_requiring_removal(
        &self,
        device_pk: i64,
    ) -> Result<Vec<GetPoliciesRequiringRemovalResult>, tokio_postgres::Error> {
        let resp = self.0.client.query(r#"select "policy_deploy"."pk", "policy_deploy"."policy", "policy_deploy"."data", "policy_deploy_status"."result" from "policy_deploy" inner join "policy_deploy_status" on ("policy_deploy_status"."deploy" = "policy_deploy"."pk" and "policy_deploy_status"."device" = $1) left join (select distinct on () "pk", "scope" from (select "pk", "scope" from ((select "policies"."pk", "direct" as "scope" from "policies" inner join "policy_assignables" on "policies"."pk" = "policy_assignables"."policy" where ("policy_assignables"."variant" = $2 and "policy_assignables"."pk" = $3)) union all (select "policies"."pk", "group" as "scope" from "policies" inner join "policy_assignables" on ("policies"."pk" = "policy_assignables"."policy" and "policy_assignables"."variant" = $4) inner join "group_assignables" on "group_assignables"."group" = "policy_assignables"."pk" where ("group_assignables"."variant" = $5 and "group_assignables"."pk" = $6))) "scoped" order by "scope" asc) "sorted") "sp" on "sp"."pk" = "policy_deploy"."policy" where "sp"."pk" is null"#, &[&device_pk,&"device",&device_pk,&"group",&"device",&device_pk]).await?;
        Ok(resp
            .into_iter()
            .map(|row| GetPoliciesRequiringRemovalResult {
                pk: row.get("pk"),
                policy_pk: row.get("policyPk"),
                data: row.get("data"),
                result: row.get("result"),
            })
            .collect())
    }
}
impl Db {
    pub async fn queued_device_actions(
        &self,
        device_id: i64,
    ) -> Result<Vec<QueuedDeviceActionsResult>, tokio_postgres::Error> {
        let resp = self.0.client.query(r#"select "action", "device", "created_by", "created_at", "deployed_at" from "device_actions" where ("device_actions"."device" = $1 and "device_actions"."deployed_at" is null)"#, &[&device_id]).await?;
        Ok(resp
            .into_iter()
            .map(|row| QueuedDeviceActionsResult {
                action: row.get("action"),
                device_pk: row.get("devicePk"),
                created_by: row.get("createdBy"),
                created_at: row.get("createdAt"),
                deployed_at: row.get("deployedAt"),
            })
            .collect())
    }
}
impl Db {
    pub async fn update_device_lastseen(
        &self,
        device_id: i64,
    ) -> Result<(), tokio_postgres::Error> {
        let last_synced = chrono::Utc::now().naive_utc();
        let resp = self
            .0
            .client
            .query(
                r#"update "devices" set "last_synced" = $1 where "devices"."pk" = $2"#,
                &[&last_synced, &device_id],
            )
            .await?;
        Ok(())
    }
}
