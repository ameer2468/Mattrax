// This file was generated by '@mattrax/drizzle-to-rs'
#![allow(unused)]
use chrono::NaiveDateTime;
use mysql_async::{prelude::*, BinaryProtocol, Deserialized, QueryResult, Serialized};

#[derive(Debug)]
pub struct GetCertificateResult {
    pub certificate: Vec<u8>,
}

#[derive(Debug)]
pub struct GetDeviceResult {
    pub pk: u64,
    pub tenant_pk: u64,
}
#[derive(Debug)]
pub struct QueuedDeviceActionsResult {
    pub action: String,
    pub device_pk: u64,
    pub created_by: u64,
    pub created_at: NaiveDateTime,
    pub deployed_at: Option<NaiveDateTime>,
}

#[derive(Clone)]
pub struct Db {
    pool: mysql_async::Pool,
}

impl Db {
    pub fn new(db_url: &str) -> Self {
        Self {
            pool: mysql_async::Pool::new(db_url),
        }
    }
}

impl Db {
    pub async fn get_certificate(
        &self,
        key: String,
    ) -> Result<Vec<GetCertificateResult>, mysql_async::Error> {
        let mut result =
            r#"select `certificate` from `certificates` where `certificates`.`key` = ?"#
                .with(mysql_async::Params::Positional(vec![key.clone().into()]))
                .run(&self.pool)
                .await?;
        let mut ret = vec![];
        while let Some(mut row) = result.next().await.unwrap() {
            ret.push(GetCertificateResult {
                certificate: FromValue::from_value(row.take(0).unwrap()),
            });
        }
        Ok(ret)
    }
}
impl Db {
    pub async fn store_certificate(
        &self,
        key: String,
        certificate: Vec<u8>,
    ) -> Result<(), mysql_async::Error> {
        let last_modified = chrono::Utc::now().naive_utc();
        let mut result = r#"insert into `certificates` (`key`, `certificate`, `last_modified`) values (?, ?, ?) on duplicate key update `certificate` = ?, `last_modified` = ?"#
			  .with(mysql_async::Params::Positional(vec![key.clone().into(),certificate.clone().into(),last_modified.clone().into(),certificate.clone().into(),last_modified.clone().into()]))
					.run(&self.pool).await?;
        Ok(())
    }
}
impl Db {
    pub async fn create_device(
        &self,
        id: String,
        name: String,
        enrollment_type: String,
        os: String,
        serial_number: String,
        tenant_pk: u64,
        owner_pk: u64,
    ) -> Result<(), mysql_async::Error> {
        let mut result = r#"insert into `devices` (`pk`, `id`, `name`, `description`, `enrollment_type`, `os`, `serial_number`, `manufacturer`, `model`, `os_version`, `imei`, `free_storage`, `total_storage`, `owner`, `azure_ad_did`, `enrolled_at`, `last_synced`, `tenant`) values (default, ?, ?, default, ?, ?, ?, default, default, default, default, default, default, ?, default, default, default, ?) on duplicate key update `name` = ?, `owner` = ?, `tenant` = ?"#
			  .with(mysql_async::Params::Positional(vec![id.clone().into(),name.clone().into(),enrollment_type.clone().into(),os.clone().into(),serial_number.clone().into(),owner_pk.clone().into(),tenant_pk.clone().into(),name.clone().into(),owner_pk.clone().into(),tenant_pk.clone().into()]))
					.run(&self.pool).await?;
        Ok(())
    }
}
impl Db {
    pub async fn get_device(
        &self,
        device_id: String,
    ) -> Result<Vec<GetDeviceResult>, mysql_async::Error> {
        let mut result = r#"select `pk`, `tenant` from `devices` where `devices`.`id` = ?"#
            .with(mysql_async::Params::Positional(vec![device_id
                .clone()
                .into()]))
            .run(&self.pool)
            .await?;
        let mut ret = vec![];
        while let Some(mut row) = result.next().await.unwrap() {
            ret.push(GetDeviceResult {
                pk: FromValue::from_value(row.take(0).unwrap()),
                tenant_pk: FromValue::from_value(row.take(1).unwrap()),
            });
        }
        Ok(ret)
    }
}
impl Db {
    pub async fn queued_device_actions(
        &self,
        device_id: u64,
    ) -> Result<Vec<QueuedDeviceActionsResult>, mysql_async::Error> {
        let mut result = r#"select `action`, `device`, `created_by`, `created_at`, `deployed_at` from `device_actions` where (`device_actions`.`device` = ? and `device_actions`.`deployed_at` is null)"#
			  .with(mysql_async::Params::Positional(vec![device_id.clone().into()]))
					.run(&self.pool).await?;
        let mut ret = vec![];
        while let Some(mut row) = result.next().await.unwrap() {
            ret.push(QueuedDeviceActionsResult {
                action: FromValue::from_value(row.take(0).unwrap()),
                device_pk: FromValue::from_value(row.take(1).unwrap()),
                created_by: FromValue::from_value(row.take(2).unwrap()),
                created_at: FromValue::from_value(row.take(3).unwrap()),
                deployed_at: FromValue::from_value(row.take(4).unwrap()),
            });
        }
        Ok(ret)
    }
}
impl Db {
    pub async fn update_device_lastseen(&self, device_id: u64) -> Result<(), mysql_async::Error> {
        let last_synced = chrono::Utc::now().naive_utc();
        let mut result = r#"update `devices` set `last_synced` = ? where `devices`.`pk` = ?"#
            .with(mysql_async::Params::Positional(vec![
                last_synced.clone().into(),
                device_id.clone().into(),
            ]))
            .run(&self.pool)
            .await?;
        Ok(())
    }
}
