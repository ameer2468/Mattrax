// This file was generated by '@mattrax/drizzle-to-rs'
#![allow(unused)]

use mysql_async::prelude::*;

#[derive(Debug)]
pub struct GetDomainResult {
    domain: String,
    secret: String,
    tenant_id: u64,
    created_at: chrono::NaiveDateTime,
    last_verification_time: Option<chrono::NaiveDateTime>,
    verified: bool,
    enterprise_enrollment_available: bool,
}
#[derive(Debug)]
pub struct GetDomainsResult {
    domain: String,
}
#[derive(Clone)]
pub struct Db {
    pool: mysql_async::Pool,
}
impl Db {
    pub fn new(db_url: &str) -> Self {
        Self {
            pool: mysql_async::Pool::new(db_url),
        }
    }
}
impl Db {
    pub async fn get_domain(
        &self,
        domain: String,
    ) -> Result<Vec<GetDomainResult>, mysql_async::Error> {
        r#"select `domain`, `secret`, `tenantId`, `createdAt`, `lastVerificationTime`, `verified`, `enterpriseEnrollmentAvailable` from `domains` where `domains`.`domain` = ?"#
            .with(mysql_async::Params::Positional(vec![domain.into()]))
            .map(&self.pool, |p: (String,String,u64,chrono::NaiveDateTime,Option<chrono::NaiveDateTime>,bool,bool,)| GetDomainResult {
                domain: p.0,secret: p.1,tenant_id: p.2,created_at: p.3,last_verification_time: p.4,verified: p.5,enterprise_enrollment_available: p.6
              })
            .await
    }
}
impl Db {
    pub async fn get_domains(&self) -> Result<Vec<GetDomainsResult>, mysql_async::Error> {
        r#"select `domain` from `domains`"#
            .with(mysql_async::Params::Positional(vec![]))
            .map(&self.pool, |p: (String,)| GetDomainsResult {
                domain: p.0
              })
            .await
    }
}
